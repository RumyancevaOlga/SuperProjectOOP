# Семинар 2

4. Создать package – data. Работу продолжаем в нем
5. Реализовать абстрактный класс User и его наследники Student и Teacher Родитель имеет в себе общие данные (фио, год рождения, паспорт (серия номер), а наследники собственные параметры (номер группы для Student, кафедра для Teacher).
9. Создать package – util. Работу продолжаем в нем
10. Создать классы WriterToTxt и ReaderFromTxt имеющие статичные методы для записи (write) /чтения (read) в/из txt файла.
6. Создать package – service. Работу продолжаем в нем
7. Создать интерфейс DataService описывающий реализацию конкретных сервисов по управлению сущностями (create, read).
8. Создать для сущности Student отдельный Service реализующий интерфейс DataService. Create и read операции реализуются путем вызова utils методов.
1. Создать package – view. Работу продолжаем в нем.
2. Создать абстрактный класс  UserView, содержащий в себе метод void showTheBest(List<User> userList) , внутри вызывающий абстрактный метод User findTheBest(List<User> userList).
3. Создать класс StudentView, унаследованный или имплементирующий UserView , содержащий в себе реализация findTheBest.

# Домашнее задание 2

1. Создать класс StudentGroup, содержащий в себе поля Teacher и список студентов.
2. Создать класс StudentGroupServiceImpl, в котором реализована логика чтения Студентов и Преподавателя из файла txt (реализация чтения файла опциональна), создания класса StudentGroup и возвращения его.
3. Создать метод в Controller createGroup(int groupNumber), в который передается номер группы, а возвращается StudentGroup. Все вышеуказанное создать согласно принципам ООП пройдённым на семинаре.

# Семинар 3

1. Создать класс StudentGroupIterator, заставив его реализовать интерфейс Iterator<Student>. Реализовать его абстрактные методы. Реализовать метод remove().
2. Модифицировать класс StudentGroup, заставив его реализовать интерфейс Iterable<Student>. Реализовать метод iterator() возвращающий экземпляр созданного нами итератора. Модифицировать класс StudentGroupServiceImpl, добавив в него метод удаления студента по ФИО. Модифицировать класс Controller, добавив в него метод удаления студента и вызывать в нем созданный метод из StudentGroupServiceImpl.
3. Модифицировать класс Student, заставив его реализовать интерфейс Comparable. Реализовать контракт compareTo () со сравнением по году рождения студента. Модифицировать класс StudentGroupServiceImpl, добавив в него метод сортировки списка студентов.
4. Создать класс UserComparator реализующий интерфейс Comparator<User>. Реализовать контракт compareTo() со сравнением по ФИО. Модифицировать класс StudentGroupServiceImpl, добавив в него метод сортировки списка студентов по ФИО.

# Домашнее задание 3

1. Создать класс GroupStream, содержащий в себе список StudentGroup и реализующий интерфейс Iterable<StudentGroup>.
2. Создать класс GroupStreamComparator<GroupStream>, реализующий сравнение количества групп входящих в GroupStream.
3. Создать класс GroupStreamServiceImpl, добавив в него метод сортировки списка потоков, используя созданный GroupStreamComparator.
4. Модифицировать класс Controller, добавив в него созданный сервис.
5. Модифицировать класс Controller, добавив в него метод, сортирующий список потоков, путем вызова созданного сервиса.


# Семинар 4

1. Создать пекедж repository. Дальнейшие работы ведем в нем. Реализовать в нем интерфейс Repository <E,I>. Задать в созданном интерфейсе 2 абстрактных метода: E save(E entity) E findById(I id). 
2. Создать класс GroupRepository, имплементировав в него репозиторий <Group,Integer>.
3. В классе StudentGroupServiceImpl добавить новую переменную Repository<Group,Integer>.
4. В классе StudentGroupServiceImpl реализовать методы сохранения группы и поиска ее по номеру.   
5. Создать интерфейс UserRepository<E extends User,I> унаследовав его от Repository<E,I>.
6. В интерфейс UserRepository<E,I> задать абстрактный метод E findByFio(String fio).
7. Создать класс StudentRepository имплементировав интерфейс UserRepository<Student, Integer>.
8. В классе StudentService добавить новую переменную StudentRepository.
9. В классе StudentService реализовать методы сохранения студента и его поиска по id и ФИО.

# Домашнее задание 4
1. Реализовать класc TeacherRepository (обобщение на ваше усмотрение).
2. Обобщить интерфейс DataService, чтобы он работал только с наследникам класса User.
3. Реализовать методы поиска и сохранения в классе TeacherService.
4. Реализовать как можно более обобщенный интерфейс Controller. Создать классы StudentController, TeacherController, GroupController с методами сохранения и поиска соответствующих объектов.
5. Реализовать такой же функционал для класса GroupStream.

# Семинар 5
1. Создать пекедж terminal. Дальнейшие работы ведем в нем.
2. Создать интерфейс CommandParser c методом String[] parseCommand (String inputCommand).
3. Создать класс TerminalReader, который содержит переменную CommandParser и метод, который в бесконечном цикле слушает команды с помощью Scanner(System.in).
4. Сделать класс TerminalReader синглтоном.
5. Создать интерфейс CommandExecutable с абстрактным методом execute().
6. Реализовать 2 класса, имплементировав созданный интерфейс, CreateStudentExecutable и DeleteStudentExecutable. В унаследованных методах они должны обращаться к методам класса StudentService.
7. Подумать какие переменные могли бы содержать созданные классы.
8. Создать класс CommandExecutableFactory.
9. Реализовать в нем метод CommandExecutable create(String[] input), где в зависимости от переданных параметров создается тот или иной класс.
10. Использовать этот класс и метод в классе TerminalReader.

# Домашнее задание 5
1. Реализовать команды для терминального клиента: удалить студента по имени удалить студента по номеру группы и возрасту.
2. Продумать логику отображения результата выполнения команды

# Семинар 6
1. Создать класс Command, который бы инкапсулировал в себе содержимое введенной команды.
2. Реализовать в нем булевские методы для проверки введенных команд.
3. Отредактировать класс CommandExecutableFactory, убрав из него хардкод и начав принимать на вход объект Command.
4. Создать класс LogingCommandExecutableFactory, наследующий класс CommandExecutableFactory. 
5. Переопределить единственный метод так, чтобы он вызывал внутри себя метод предка, но в начале и конце распечатывал информацию о входных и выходных параметрах.
6. Переименовать класс CommandExecutableFactory в CommandExecutableFactoryImpl.
7. Создать интерфейс CommandExecutableFactory и имплементировать от него класс CommandExecutableFactoryImpl.
8. В классе TerminalReader реализовать DIP, то есть возможность менять реализации CommandExecutableFactory.

# Домашнее задание 6
1. Повторить задания с семинара 6
2. Проверить и отредактировать весь проект на предмет соответствия SOLID
Вместе с ссылкой указать, что вы поменяли и исходя из какого принципа
3. * Продумать логику отображения результата выполнения команды

# Семинар 7
1. Создать пекедж db.
2. Реализовать в нем абстрактный обобщенный класс Table, содержащий в себе переменную List<E> elements.
3. Реализовать в классе метод добавления элемента E save(E entity), который внутри себя добавляет entity в переменную elements.
4. Создать класс StudentTable. 
5. Реализовать метод удаления по имени boolean removeByName (String name), который бы удалял студента из таблицы по имени.
6. Создать в классе StudentRepository зависимость класса StudentTable. 
7. Вызывать метод removeByName из одноименного метода класса.
8. Создать реализацию CommandParser. Чтобы разбить строку, используйте метод split().
9. Запустить приложение, вызвав метод класса TerminalReader, не забыв создать экземпляры зависимостей.

# Домашнее задание 7
1. Повторить задания 1,2 с семинара 7.
2. Выполнить задание 3 с семинара 7.
3. Реализовать метод save класса StudentRepository так, чтобы он в своем теле вызывал метод create класса StudentTable.

Критерии оценки :
приложение запускается
можно с терминала создать студента и удалить студента по имени
